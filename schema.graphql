type Tld @entity {
  "The namehash of the name"
  id: ID!
  "The human readable name"
  name: String
  "The human readable label name"
  labelName: String
  "keccak256(labelName)"
  labelhash: Bytes
  "The resolver that controls the domain's settings"
  resolver: Resolver
  "The time when the domain was created"
  createdAt: BigInt!
  "The account that owns the domain"
  owner: Account!
  "The claim associated with the TLD"
  claim: TldClaimed @derivedFrom(field: "tld")
  # "The events associated with the domain"
  # events: [DomainEvent!]! @derivedFrom(field: "domain")
}

type TldResolverSet @entity {
  id: ID!
  _nftNamehash: Bytes! # bytes32
  _resolver: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TldTransfer @entity {
  id: ID!
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TldClaimed @entity {
  "The unique identifier of the claim"
  id: ID!
  "The TLD associated with the claim"
  tld: Tld!
  "The claim date of the TLD"
  claimDate: BigInt!
  "The account that registered the domain"
  claimant: Account!
  "The human-readable label name of TLD"
  labelName: String
  "keccak256(labelName)"
  labelhash: Bytes
  "The block number of the event"
  blockNumber: Int!
  "The transaction ID associated with the event"
  transactionID: Bytes!
}

type AllowedTldMintUpdate @entity {
  id: ID!
  _claimant: Bytes! # address
  _manager: Bytes! # address
  _label: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UpdateAllowedTldManager @entity {
  id: ID!
  _addr: Bytes! # address
  _allowed: Boolean! # bool
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Domain @entity {
  "The namehash of the name"
  id: ID!
  "The human readable name"
  name: String
  "The human readable label name"
  labelName: String
  "keccak256(labelName)"
  labelhash: Bytes
  "The namehash (id) of the parent name"
  parent: Tld!
  "The resolver that controls the domain's settings"
  resolver: Resolver
  "The time when the domain was created"
  createdAt: BigInt!
  "The account that owns the domain"
  owner: Account!
  "The account that owns the ERC721 NFT for the domain"
  registrant: Account
  "The expiry date for the domain"
  expiryDate: BigInt
  "The registration associated with the domain"
  registration: Registration @derivedFrom(field: "domain")
  "The events associated with the domain"
  events: [DomainEvent!]! @derivedFrom(field: "domain")
}

type SldResolverSet @entity {
  id: ID!
  _nftNamehash: Bytes! # bytes32
  _resolver: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type SldTransfer @entity {
  id: ID!
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type RenewSld @entity {
  id: ID!
  _tldNamehash: Bytes! # bytes32
  _label: String! # string
  _expiry: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}


interface DomainEvent {
  "The unique identifier of the event"
  id: ID!
  "The domain name associated with the event"
  domain: Domain!
  "The block number at which the event occurred"
  blockNumber: Int!
  "The transaction hash of the transaction that triggered the event"
  transactionID: Bytes!
}

type Transfer implements DomainEvent @entity {
  "The unique identifier of the event"
  id: ID!
  "The domain name associated with the event"
  domain: Domain!
  "The block number at which the event occurred"
  blockNumber: Int!
  "The transaction hash of the transaction that triggered the event"
  transactionID: Bytes!
  "The account that owns the domain after the transfer"
  owner: Account!
}

type NewOwner implements DomainEvent @entity {
  "The unique identifier of the event"
  id: ID!
  "The parent domain of the domain name associated with the event"
  parentDomain: Domain
  "The domain name associated with the event"
  domain: Domain!
  "The block number at which the event occurred"
  blockNumber: Int!
  "The transaction hash of the transaction that triggered the event"
  transactionID: Bytes!
  "The new account that owns the domain"
  owner: Account!
}

type NewResolver implements DomainEvent @entity {
  "The unique identifier of the event"
  id: ID!
  "The domain name associated with the event"
  domain: Domain!
  "The block number at which the event occurred"
  blockNumber: Int!
  "The transaction hash of the transaction that triggered the event"
  transactionID: Bytes!
  "The new resolver contract address associated with the domain"
  resolver: Resolver!
}

type Registration @entity {
  "The unique identifier of the registration"
  id: ID!
  "The domain name associated with the registration"
  domain: Domain!
  "The registration date of the domain"
  registrationDate: BigInt!
  "The expiry date of the domain"
  expiryDate: BigInt!
  "The cost associated with the domain registration"
  cost: BigInt
  "The account that registered the domain"
  registrant: Account!
  "The human-readable label name associated with the domain registration"
  labelName: String
   "The events associated with the domain registration"
   events: [RegistrationEvent!]! @derivedFrom(field: "registration")
}

interface RegistrationEvent {
  "The unique identifier of the registration event"
  id: ID!
  "The registration associated with the event"
  registration: Registration!
  "The block number of the event"
  blockNumber: Int!
  "The transaction ID associated with the event"
  transactionID: Bytes!
}

type NameRegistered implements RegistrationEvent @entity {
  "The unique identifier of the NameRegistered event"
  id: ID!
  "The registration associated with the event"
  registration: Registration!
  "The block number of the event"
  blockNumber: Int!
  "The transaction ID associated with the event"
  transactionID: Bytes!
  "The account that registered the name"
  registrant: Account!
  "The expiry date of the registration"
  expiryDate: BigInt!
}

type NameRenewed implements RegistrationEvent @entity {
  "The unique identifier of the NameRenewed event"
  id: ID!
  "The registration associated with the event"
  registration: Registration!
  "The block number of the event"
  blockNumber: Int!
  "The transaction ID associated with the event"
  transactionID: Bytes!
  "The new expiry date of the registration"
  expiryDate: BigInt!
}

type NameTransferred implements RegistrationEvent @entity {
  "The ID of the event"
  id: ID!
  "The registration associated with the event"
  registration: Registration!
  "The block number of the event"
  blockNumber: Int!
  "The transaction ID of the event"
  transactionID: Bytes!
  "The new owner of the domain"
  newOwner: Account!
}

type Account @entity {
  "The unique identifier for the account"
  id: ID!
  "The domains owned by the account"
  domains: [Domain!]! @derivedFrom(field: "owner")
  "The Registrations made by the account"
  registrations: [Registration!] @derivedFrom(field: "registrant")
}

type PaymentSent @entity {
  id: ID!
  _to: Bytes! # address
  _amount: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DiscountSet @entity {
  id: ID!
  _tokenNamehash: Bytes! # bytes32
  _claimant: Bytes! # address
  _discount_startTimestamp: BigInt! # uint80
  _discount_endTimestamp: BigInt! # uint80
  _discount_discountPercentage: Int! # uint8
  _discount_isRegistration: Boolean! # bool
  _discount_isRenewal: Boolean! # bool
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type EnabledSet @entity {
  id: ID!
  _tokenNamehash: Bytes! # bytes32
  _enabled: Boolean! # bool
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type LengthCostSet @entity {
  id: ID!
  _tokenNamehash: Bytes! # bytes32
  _prices: [BigInt!]! # uint256[]
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type MultiYearDiscountSet @entity {
  id: ID!
  _tokenNamehash: Bytes! # bytes32
  _discounts: [BigInt!]! # uint256[]
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type PremiumNameSet @entity {
  id: ID!
  _tokenNamehash: Bytes! # bytes32
  _price: BigInt! # uint256
  _label: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ReservedNameSet @entity {
  id: ID!
  _tokenNamehash: Bytes! # bytes32
  _claimant: Bytes! # address
  _label: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type SldApproval @entity {
  id: ID!
  owner: Bytes! # address
  approved: Bytes! # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type SldApprovalForAll @entity {
  id: ID!
  owner: Bytes! # address
  operator: Bytes! # address
  approved: Boolean! # bool
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}


type Resolver @entity {
  "The unique identifier for this resolver, which is a concatenation of the resolver address and the domain namehash"
  id: ID!
  "The domain that this resolver is associated with"
  domain: Domain
  "The address of the resolver contract"
  address: Bytes!
}

type AddrChanged @entity {
  id: ID!
  node: Bytes! # bytes32
  a: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type AddressChanged @entity {
  id: ID!
  node: Bytes! # bytes32
  coinType: BigInt! # uint256
  newAddress: Bytes! # bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ContenthashChanged @entity {
  id: ID!
  node: Bytes! # bytes32
  hash: Bytes! # bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DNSRecordChanged @entity {
  id: ID!
  node: Bytes! # bytes32
  name: Bytes! # bytes
  resource: Int! # uint16
  record: Bytes! # bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DNSRecordDeleted @entity {
  id: ID!
  node: Bytes! # bytes32
  name: Bytes! # bytes
  resource: Int! # uint16
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type DNSZonehashChanged @entity {
  id: ID!
  node: Bytes! # bytes32
  lastzonehash: Bytes! # bytes
  zonehash: Bytes! # bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NameChanged @entity {
  id: ID!
  node: Bytes! # bytes32
  name: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ReverseClaimed @entity {
  id: ID!
  _addr: Bytes! # address
  _domain: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TextChanged @entity {
  id: ID!
  node: Bytes! # bytes32
  indexedKey: Bytes! # bytes32
  key: String! # string
  value: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UpdatedDelegate @entity {
  id: ID!
  _owner: Bytes! # address
  _tokenId: BigInt! # uint256
  _delegate: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type VersionChanged @entity {
  id: ID!
  node: Bytes! # bytes32
  newVersion: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

#type Initialized @entity {
#  id: ID!
#  version: Int! # uint8
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type NewLabelValidator @entity {
#  id: ID!
#  _labelValidator: Bytes! # address
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type NewUsdOracle @entity {
#  id: ID!
#  _usdEthPriceOracle: Bytes! # address
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type OwnershipTransferred @entity {
#  id: ID!
#  previousOwner: Bytes! # address
#  newOwner: Bytes! # address
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type TldClaimed @entity {
#  id: ID!
#  _to: Bytes! # address
#  _tokenId: BigInt! # uint256
#  _label: String! # string
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type UpdateAllowedTldManager @entity {
#  id: ID!
#  _addr: Bytes! # address
#  _allowed: Boolean! # bool
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#type Approval @entity {
#  id: ID!
#  owner: Bytes! # address
#  approved: Bytes! # address
#  tokenId: BigInt! # uint256
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type ApprovalForAll @entity {
#  id: ID!
#  owner: Bytes! # address
#  operator: Bytes! # address
#  approved: Boolean! # bool
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type HandshakeTldOwnershipTransferred @entity {
#  id: ID!
#  previousOwner: Bytes! # address
#  newOwner: Bytes! # address
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type RegistrationStrategySet @entity {
#  id: ID!
#  namehash: Bytes! # bytes32
#  strategy: Bytes! # address
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type ResolverSet @entity {
#  id: ID!
#  _nftNamehash: Bytes! # bytes32
#  _resolver: Bytes! # address
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type Transfer @entity {
#  id: ID!
#  from: Bytes! # address
#  to: Bytes! # address
#  tokenId: BigInt! # uint256
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#type HandshakeSldOwnershipTransferred @entity {
#  id: ID!
#  previousOwner: Bytes! # address
#  newOwner: Bytes! # address
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type HandshakeSldResolverSet @entity {
#  id: ID!
#  _nftNamehash: Bytes! # bytes32
#  _resolver: Bytes! # address
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type RoyaltyPayoutAddressSet @entity {
#  id: ID!
#  _nftNamehash: Bytes! # bytes32
#  _payoutAddress: Bytes! # address
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type RoyaltyPayoutAmountSet @entity {
#  id: ID!
#  _nftNamehash: Bytes! # bytes32
#  _amount: BigInt! # uint256
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type HandshakeSldTransfer @entity {
#  id: ID!
#  from: Bytes! # address
#  to: Bytes! # address
#  tokenId: BigInt! # uint256
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type SldRegistrationManagerInitialized @entity {
#  id: ID!
#  version: Int! # uint8
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type NewGracePeriod @entity {
#  id: ID!
#  _newGracePeriod: BigInt! # uint256
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type SldRegistrationManagerNewLabelValidator @entity {
#  id: ID!
#  _labelValidator: Bytes! # address
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type SldRegistrationManagerNewUsdOracle @entity {
#  id: ID!
#  _usdEthPriceOracle: Bytes! # address
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type SldRegistrationManagerOwnershipTransferred @entity {
#  id: ID!
#  previousOwner: Bytes! # address
#  newOwner: Bytes! # address
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#
#type RegisterSld @entity {
#  id: ID!
#  _tldNamehash: Bytes! # bytes32
#  _secret: Bytes! # bytes32
#  _label: String! # string
#  _expiry: BigInt! # uint256
#  blockNumber: BigInt!
#  blockTimestamp: BigInt!
#  transactionHash: Bytes!
#}
#

